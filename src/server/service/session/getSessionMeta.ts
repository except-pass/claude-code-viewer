import { statSync } from "node:fs";
import { access, readFile } from "node:fs/promises";
import { dirname } from "node:path";
import { isWorkingDirectoryClean } from "../git/getStatus";
import { type ParsedCommand, parseCommandXml } from "../parseCommandXml";
import { parseJsonl } from "../parseJsonl";
import type { SessionMeta } from "../types";
import { isWorktreeSession } from "../worktree/utils";

const firstCommandCache = new Map<string, ParsedCommand | null>();

const ignoreCommands = [
  "/clear",
  "/login",
  "/logout",
  "/exit",
  "/mcp",
  "/memory",
];

const getFirstCommand = (
  jsonlFilePath: string,
  lines: string[],
): ParsedCommand | null => {
  const cached = firstCommandCache.get(jsonlFilePath);
  if (cached !== undefined) {
    return cached;
  }

  let firstCommand: ParsedCommand | null = null;

  for (const line of lines) {
    const conversation = parseJsonl(line).at(0);

    if (conversation === undefined || conversation.type !== "user") {
      continue;
    }

    const firstUserText =
      conversation === null || !conversation.message
        ? null
        : typeof conversation.message.content === "string"
          ? conversation.message.content
          : (() => {
              const firstContent = conversation.message.content.at(0);
              if (firstContent === undefined) return null;
              if (typeof firstContent === "string") return firstContent;
              if (firstContent.type === "text") return firstContent.text;
              return null;
            })();

    if (firstUserText === null) {
      continue;
    }

    if (
      firstUserText ===
      "Caveat: The messages below were generated by the user while running local commands. DO NOT respond to these messages or otherwise consider them in your response unless the user explicitly asks you to."
    ) {
      continue;
    }

    const command = parseCommandXml(firstUserText);
    if (command.kind === "local-command") {
      continue;
    }

    if (
      command.kind === "command" &&
      ignoreCommands.includes(command.commandName)
    ) {
      continue;
    }

    firstCommand = command;
    break;
  }

  if (firstCommand !== null) {
    firstCommandCache.set(jsonlFilePath, firstCommand);
  }

  return firstCommand;
};

/**
 * Extract working directory from session JSONL content
 */
const getWorkingDirectoryFromContent = (lines: string[]): string | null => {
  for (const line of lines) {
    const conversation = parseJsonl(line).at(0);
    if (
      conversation === undefined ||
      conversation === null ||
      // Skip meta-only entries
      (conversation as any).type === "summary" ||
      (conversation as any).type === "x-error"
    ) {
      continue;
    }

    const cwd = (conversation as any).cwd as string | undefined;
    if (cwd && cwd.length > 0) {
      return cwd;
    }
  }
  return null;
};

export const getSessionMeta = async (
  jsonlFilePath: string,
): Promise<SessionMeta> => {
  const stats = statSync(jsonlFilePath);
  const lastModifiedUnixTime = stats.ctime.getTime();

  const content = await readFile(jsonlFilePath, "utf-8");
  const lines = content.split("\n");

  const sessionMeta: SessionMeta = {
    messageCount: lines.length,
    firstCommand: getFirstCommand(jsonlFilePath, lines),
    lastModifiedAt: lastModifiedUnixTime
      ? new Date(lastModifiedUnixTime).toISOString()
      : null,
  };

  // Check if this is a worktree session and if it's dirty/orphaned
  if (isWorktreeSession(jsonlFilePath)) {
    try {
      // Try to get working directory from content first
      let workingDirectory = getWorkingDirectoryFromContent(lines);

      // Fallback to the directory containing the JSONL file
      if (!workingDirectory) {
        workingDirectory = dirname(jsonlFilePath);
      }

      // Check if the worktree directory still exists
      try {
        await access(workingDirectory);
        // Directory exists, check if it's dirty
        const cleanResult = await isWorkingDirectoryClean(workingDirectory);
        if (cleanResult.success) {
          sessionMeta.isDirty = !cleanResult.data; // isDirty is opposite of isClean
        }
        sessionMeta.isOrphaned = false;
      } catch {
        // Directory doesn't exist, mark as orphaned
        sessionMeta.isOrphaned = true;
      }
    } catch (error) {
      // If any check fails, treat as orphaned
      console.warn(
        `Failed to check worktree session status ${jsonlFilePath}:`,
        error,
      );
      sessionMeta.isOrphaned = true;
    }
  }

  return sessionMeta;
};
